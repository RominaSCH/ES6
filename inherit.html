<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>상속</title>
</head>
<body>
    <script>
        //상속기능을 구현하는 ES5 방법
        //Object.create(프로토타입 object); 

        /*  var 부모 = {
            name : "Kim",
            age : 50,
        }
        var 자식 = Object.create(부모);
        자식.age = 20;
        var 손자 = Object.create(자식); */

        //상속기능을 구현하는 ES6 방법 : class
        class 부모 {
            constructor(parameter){
                this.name = "parameter";
                this.sayHi = function(){ console.log("hello") } //여기에 쓰면 자식이 직접 함수를 가진다.
            }
            // function sayHi(){ console.log("hello") } //여기에 쓰면 자식 오브젝트에 추가 안됨.
            //부모.prototype에 추가된다
        }
        // 부모.prototype.sayHello = function(){ }

        var 자식 = new 부모();
        // 자식.__proto__ 는 부모.prototype 와 같다
        Object.getPrototypeOf(자식); // 는 자식.__proto__와 같다. 부모님 prototype 출력해주세요



        //객체지향 문법은 왜 쓰냐면, 
        // 1. object 여러개를 쉽게 만들어 쓰려고

        class 할아버지{
            constructor(name, height){
                this.성 = "Kim";
                this.이름 = name;
                this.키 = height;
            }
            sayHi(){
                console.log("암유어그랜파")
            }
        }
        class 아버지 extends 할아버지{ //할아버지의 속성들을 물려받아서 아버지를 만들겠다.
            constructor(name, height){
                //this.나이 = 70; //이거 에러남. extends 해서 만든 class는 this 그냥 못쓴다.
                super(name, height);//extends 받은 속성 복붙하겠다 이런 의미임. 이거 쓰고 나서 this 써야함
                //위 super는 부모 class의 constructor를 의미한다
                this.나이 = 30;
            }
            sayHi(){
                console.log("암유어파더")
                super.sayHi(); //여기의 super는 부모 class의 prototype을 의미한다. 
                // = console.log("암유어그랜파")
            }
        }
        var 아버지1 = new 아버지('민수', 172);

    </script>
</body>
</html>